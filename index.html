<!DOCTYPE html>
<html lang="en">
  <head>
    <title>
      Gamepad
    </title>
    <meta charset="utf-8"><!--
      === NOTA BENE ===
      For the three scripts below, if your spec resides on dev.w3 you can check them
      out in the same tree and use relative links so that they'll work offline,
     -->

    <script src='https://www.w3.org/Tools/respec/respec-w3c' class=
    'remove'></script>
    <script class='remove'>
      var respecConfig = {
          // specification status (e.g. WD, LCWD, NOTE, etc.). If in doubt use ED.
          specStatus:           "ED",
          // if your specification has a subtitle that goes below the main
          // formal title, define it here
          // subtitle   :  "an excellent document",

          // if you wish the publication date to be other than today, set this
          //publishDate:  "2011-01-01",

          // if the specification's copyright date is a range of years, specify
          // the start date here:
          // copyrightStart: "2005"

          // if there is a previously published draft, uncomment this and set its YYYY-MM-DD date
          // and its maturity status
          testSuiteURI: "https://github.com/web-platform-tests/wpt/tree/master/gamepad",

          // if this is a LCWD, uncomment and set the end of its review period
          // lcEnd: "2009-08-05",

          // editors, add as many as you like
          // only "name" is required
          editors:  [
              { name: "Steve Agoston", w3cid: "103815",
                company: "Sony", companyURL: "https://www.sony.com/"},
              { name: "James Hollyer", w3cid: "115233",
                company: "Google", companyURL: "https://www.google.com/"},
              { name: "Matt Reynolds", w3cid: "105511",
                company: "Google", companyURL: "https://www.google.com/"},
          ],

          formerEditors: [
              { name: "Brandon Jones", url: "http://tojicode.com/",
                company: "Google", companyURL: "http://www.google.com/",
                w3cid: 87824 },
              { name: "Scott Graham", url: "http://h4ck3r.net/",
                company: "Google", companyURL: "https://www.google.com/",
                w3cid: 49028 },
              { name: "Ted Mielczarek", url: "http://ted.mielczarek.org/",
                company: "Mozilla", companyURL: "http://www.mozilla.org/",
                w3cid: 49656 },
          ],

          github: "w3c/gamepad",

          group: "webapps",

          implementationReportURI: "https://wpt.fyi/results/gamepad",
          caniuse: "gamepad",
          xref: ["HTML", "DOM"],
      };
    </script>
    <style type="text/css">
      .event {
        font-family: monospace;
        color: #459900;
      }

      pre.idl {
        white-space: pre-wrap;
      }
      .tg {
        border-collapse: collapse;
        border-spacing: 0;

      }
      .tg th {
        border-style: solid;
        border-width: 1px;
        background: #90b8de;
        color: #fff;
        font-family: sans-serif;
        font-weight: bold;
        border-color: grey;
      }
      .tg td {
        padding: 4px 5px;
        background-color: rgb(221, 238, 255);
        font-family: monospace;
        border-style: solid;
        border-width: 1px;
        border-color: grey;
        overflow: hidden;
        word-break: normal;
      }
    </style>
  </head>
  <body data-cite="secure-contexts">
    <section id='abstract'>
      <p>
        The Gamepad specification defines a low-level interface that represents
        gamepad devices.
      </p>
    </section>
    <section id='sotd'>
      <p>
        This is a work in progress.
      </p>
    </section>
    <section id='introduction' class='informative'>
      <h2>
        Introduction
      </h2>
      <p>
        Some <a>user agent</a>s have connected gamepad devices. These devices
        are desirable and suited to input for gaming applications, and for "10
        foot" user interfaces (presentations, media viewers).
      </p>
      <p>
        Currently, the only way for a gamepad to be used as input would be to
        emulate mouse or keyboard events, however this would lose information
        and require additional software outside of the <a>user agent</a> to
        accomplish emulation.
      </p>
      <p>
        Meanwhile, native applications are capable of accessing these devices
        via system APIs.
      </p>
      <p>
        The Gamepad API provides a solution to this problem by specifying
        interfaces that allow web applications to directly act on gamepad data.
      </p>
    </section>
    <section>
      <h2>
        Dependencies
      </h2>
      <p>
        This specification references interfaces from a number of other
        specifications:
      </p>
      <ul>
        <li>
          <dfn data-cite=
          "navigation-timing#performancetiming">PerformanceTiming</dfn>
          [[NAVIGATION-TIMING]].
        </li>
      </ul>
    </section>
    <section>
      <h2>
        Scope
      </h2>
      <p>
        Interfacing with external devices designed to control games has the
        potential to become large and intractable if approached in full
        generality. In this specification we explicitly choose to narrow scope
        to provide a useful subset of functionality that can be widely
        implemented and broadly useful.
      </p>
      <p>
        Specifically, we choose to only support the functionality required to
        support gamepads. Support for gamepads requires two input types:
        buttons and axes. Both buttons and axes are reported as analog values,
        buttons ranging from [0..1], and axes ranging from [-1..1].
      </p>
      <p>
        While the primary goal is support for gamepad devices, supporting these
        two types of analog inputs allows support for other similar devices
        common to current gaming systems including joysticks, driving wheels,
        pedals, and accelerometers. As such, the name "gamepad" is exemplary
        rather than trying to be a generic name for the entire set of devices
        addressed by this specification.
      </p>
      <p>
        We specifically exclude support for more complex devices that may also
        be used in some gaming contexts, including those that that do motion
        sensing, depth sensing, video analysis, gesture recognition, and so on.
      </p>
    </section>
    <section data-dfn-for="Gamepad" data-link-for="Gamepad">
      <h2>
        <dfn>Gamepad</dfn> interface
      </h2>
      <p>
        This interface defines an individual gamepad device.
      </p>
      <pre class="idl" data-cite="HR-TIME">
        [Exposed=Window, SecureContext]
        interface Gamepad {
          readonly attribute DOMString id;
          readonly attribute long index;
          readonly attribute boolean connected;
          readonly attribute DOMHighResTimeStamp timestamp;
          readonly attribute GamepadMappingType mapping;
          readonly attribute FrozenArray&lt;double&gt; axes;
          readonly attribute FrozenArray&lt;GamepadButton&gt; buttons;
        };
      </pre>
      <dl>
        <dt>
          <dfn>id</dfn> attribute
        </dt>
        <dd>
          An identification string for the gamepad. This string identifies the
          brand or style of connected gamepad device. Typically, this will
          include the USB vendor and a product ID.
        </dd>
        <dt>
          <dfn>index</dfn> attribute
        </dt>
        <dd>
          The index of the gamepad in the {{Navigator}}. When multiple gamepads
          are connected to a <a>user agent</a>, indices MUST be assigned on a
          first-come, first-serve basis, starting at zero. If a gamepad is
          disconnected, previously assigned indices MUST NOT be reassigned to
          gamepads that continue to be connected. However, if a gamepad is
          disconnected, and subsequently the same or a different gamepad is
          then connected, the lowest previously used index MUST be reused.
        </dd>
        <dt>
          <dfn>connected</dfn> attribute
        </dt>
        <dd>
          Indicates whether the physical device represented by this object is
          still connected to the system. When a gamepad becomes unavailable,
          whether by being physically disconnected, powered off or otherwise
          unusable, the `connected` attribute MUST be set to false.
        </dd>
        <dt>
          <dfn>timestamp</dfn> attribute
        </dt>
        <dd>
          Last time the data for this gamepad was updated. Timestamp is a
          monotonically increasing value that allows the author to determine if
          the <a>axes</a> and <a>button</a> data have been updated from the
          hardware. The value must be relative to the
          <code>navigationStart</code> attribute of the
          <a>PerformanceTiming</a> interface. Since values are monotonically
          increasing they can be compared to determine the ordering of updates,
          as newer values will always be greater than or equal to older values.
          If no data has been received from the hardware, the value of the
          <code>timestamp</code> attribute should be the time relative to
          <code>navigationStart</code> when the <a>Gamepad</a> object was first
          made available to script.
        </dd>
        <dt>
          <dfn>mapping</dfn> attribute
        </dt>
        <dd>
          The mapping in use for this device. If the user agent has knowledge
          of the layout of the device, then it SHOULD indicate that a mapping
          is in use by setting this property to a known mapping name. Currently
          the only known mapping is {{GamepadMappingType["standard"]}}, which
          corresponds to the <a>Standard Gamepad layout</a>. If the user agent
          does not have knowledge of the device layout and is simply providing
          the controls as represented by the driver in use, then it MUST set
          the `mapping` property to the empty string.
        </dd>
        <dt>
          <dfn>axes</dfn> attribute
        </dt>
        <dd>
          Array of values for all axes of the gamepad. All axis values MUST be
          linearly normalized to the range [-1.0 .. 1.0]. If the controller is
          perpendicular to the ground with the directional stick pointing up,
          -1.0 SHOULD correspond to "forward" or "left", and 1.0 SHOULD
          correspond to "backward" or "right". Axes that are drawn from a 2D
          input device SHOULD appear next to each other in the axes array, X
          then Y. It is RECOMMENDED that axes appear in decreasing order of
          importance, such that element 0 and 1 typically represent the X and Y
          axis of a directional stick. The same object MUST be returned until
          the <a>user agent</a> needs to return different values (or values in
          a different order).
        </dd>
        <dt>
          <dfn>buttons</dfn> attribute
        </dt>
        <dd>
          Array of button states for all buttons of the gamepad. It is
          RECOMMENDED that buttons appear in decreasing importance such that
          the primary button, secondary button, tertiary button, and so on
          appear as elements 0, 1, 2, ... in the buttons array. The same object
          MUST be returned until the <a>user agent</a> needs to return
          different values (or values in a different order).
        </dd>
      </dl>
    </section>
    <section data-dfn-for="GamepadButton" data-link-for="GamepadButton">
      <h2>
        <dfn>GamepadButton</dfn> Interface
      </h2>
      <p>
        This interface defines the state of an individual button on a gamepad
        device.
      </p>
      <pre class="idl">
        [Exposed=Window, SecureContext]
        interface GamepadButton {
          readonly attribute boolean pressed;
          readonly attribute boolean touched;
          readonly attribute double value;
        };
      </pre>
      <dl>
        <dt>
          <dfn>pressed</dfn> attribute
        </dt>
        <dd>
          The pressed state of the button. This property MUST be true if the
          button is currently pressed, and false if it is not pressed. For
          buttons which do not have a digital switch to indicate a pure pressed
          or released state, the <a>user agent</a> MUST choose a threshold
          value to indicate the button as pressed when its value is above a
          certain amount. If the platform API gives a recommended value, the
          user agent SHOULD use that. In other cases, the user agent SHOULD
          choose some other reasonable value.
        </dd>
        <dt>
          <dfn>touched</dfn> attribute
        </dt>
        <dd>
          The touched state of the button. If the button is capable of
          detecting touch, this property MUST be true if the button is
          currently being touched, and false otherwise. If the button is not
          capable of detecting touch and is capable of reporting an analog
          value, this property MUST be true if the value property is greater
          than 0, and false if the value is 0. If the button is not capable of
          detecting touch and can only report a digital value, this property
          MUST mirror the <a>pressed</a> attribute.
        </dd>
        <dt>
          <dfn>value</dfn> attribute
        </dt>
        <dd>
          For buttons that have an analog sensor, this property MUST represent
          the amount which the button has been pressed. All button values MUST
          be linearly normalized to the range [0.0 .. 1.0]. 0.0 MUST mean fully
          unpressed, and 1.0 MUST mean fully pressed. For buttons without an
          analog sensor, only the values 0.0 and 1.0 for fully unpressed and
          fully pressed respectively, MUST be provided.
        </dd>
      </dl>
    </section>
    <section data-dfn-for="GamepadMappingType">
      <h2>
        <dfn>GamepadMappingType</dfn> enum
      </h2>
      <p>
        This enum defines the set of known mappings for a Gamepad.
      </p>
      <pre class="idl">
        enum GamepadMappingType {
          "",
          "standard",
        };
      </pre>
      <dl>
        <dt>
          <dfn>""</dfn>
        </dt>
        <dd>
          The empty string indicates that no mapping is in use for this
          gamepad.
        </dd>
        <dt>
          <dfn>standard</dfn>
        </dt>
        <dd>
          The Gamepad's controls have been mapped to the <a href=
          "#remapping">Standard Gamepad layout</a>.
        </dd>
      </dl>
    </section>
    <section data-dfn-for="Navigator">
      <h2>
        Navigator Interface extension
      </h2>
      <p>
        This partial interface defines an extension to the Navigator interface.
      </p>
      <pre class="idl">
        [Exposed=Window]
        partial interface Navigator {
          sequence&lt;Gamepad?&gt; getGamepads();
        };
      </pre>
      <dl>
        <dt>
          <dfn>getGamepads()</dfn>
        </dt>
        <dd>
          <p class="note">
            The gamepad state returned from {{Navigator/getGamepads()}} does
            not reflect disconnection or connection until after the
            <a>gamepaddisconnected</a> or <a>gamepadconnected</a> events have
            fired.
          </p>
          <p>
            If the <a>current settings object</a>'s [=environment settings
            object / responsible document=] is not <a>allowed to use</a> the
            "`gamepad`" permission, then [=exception/throw=] a
            {{"SecurityError"}} {{DOMException}}.
          </p>
        </dd>
        <dd>
          Retrieve a snapshot of the data for the the currently connected and
          interacted-with gamepads. Gamepads MUST only appear in the list if
          they are currently connected to the <a>user agent</a>, and at least
          one device has been interacted with by the user. If no devices have
          been interacted with, devices MUST NOT appear in the list to avoid a
          malicious page from fingerprinting the user. The length of the array
          returned MUST be one more than the maximum index value of the Gamepad
          objects returned in the array. The entries in the array MUST be the
          set of Gamepad objects that are visible to the current page, with
          each Gamepad present at the index in the array specified by its
          {{Gamepad/index}} attribute. Array indices for which there is no
          connected Gamepad with the corresponding index should return null.
          <p>
            The gamepad state returned from getGamepads() does not reflect
            disconnection or connection until after the
            <a>gamepaddisconnected</a> or <a>gamepadconnected</a> events have
            fired.
          </p>
          <p>
            As an example, if there is one connected gamepad with an index of
            1, then the following code snippet describes the expected behavior:
          </p>
          <pre class="example highlight">
            // gamepads should look like [null, [object Gamepad]]
            var gamepads = navigator.getGamepads();
            // The following statements should all evaluate to true.
            gamepads[0] == null;
            gamepads[1].index == 1;
            gamepads.length == 2;
          </pre>
        </dd>
      </dl>
    </section>
    <section data-dfn-for="GamepadEvent">
      <h2>
        <dfn>GamepadEvent</dfn> Interface
      </h2>
      <pre class="idl" data-cite="DOM">
        [Exposed=Window, SecureContext]

        interface GamepadEvent: Event {
          constructor(DOMString type, GamepadEventInit eventInitDict);
          [SameObject] readonly attribute Gamepad gamepad;
        };
      </pre>
      <dl>
        <dt>
          <dfn>gamepad</dfn>
        </dt>
        <dd>
          The single gamepad attribute provides access to the associated
          gamepad data for this event.
        </dd>
      </dl>
      <section>
        <h3>
          <dfn>GamepadEventInit</dfn> dictionary
        </h3>
        <pre class="idl" data-cite="DOM">
        dictionary GamepadEventInit : EventInit {
          required Gamepad gamepad;
        };
      </pre>
        <dl data-dfn-for="GamepadEventInit">
          <dt>
            <dfn>gamepad</dfn> member
          </dt>
          <dd>
            The gamepad associated with this event.
          </dd>
        </dl>
      </section>
    </section>
    <section>
      <h2>
        <dfn data-lt="Standard Gamepad layout">Remapping</dfn>
      </h2>
      <p>
        Each device manufacturer creates many different products and each has
        unique styles and layouts of buttons and axes. It is intended that the
        <a>user agent</a> support as many of these as possible.
      </p>
      <p>
        Additionally there are <em>de facto</em> standard layouts that have
        been made popular by game consoles. When the <a>user agent</a>
        recognizes the attached device, it is RECOMMENDED that it be remapped
        to a canonical ordering when possible. Devices that are not recognized
        should still be exposed in their raw form.
      </p>
      <p data-link-for="Gamepad">
        There is currently one canonical device, the "Standard Gamepad". The
        standard gamepad has 4 axes, and up to 17 buttons. When remapping, the
        indices in <a>axes</a>[] and <a>buttons</a>[] should correspond as
        closely as possible to the physical locations in the diagram below.
        Additionally, the <a>mapping</a> property of the Gamepad SHOULD be set
        to the string {{GamepadMappingType["standard"]}}.
      </p>
      <p>
        The "Standard Gamepad" physical button locations are layed out in a
        left cluster of four buttons, a right cluster of four buttons, a center
        cluster of three buttons, and a pair of front facing buttons on the
        left and right side of the gamepad. The four axes of the "Standard
        Gamepad" are associated with a pair of analog sticks, one on the left
        and one on the right. The following table describes the buttons/axes
        and their physical locations.
      </p>
      <table class="tg">
        <thead>
          <tr>
            <th>
              Button/Axis
            </th>
            <th>
              Location
            </th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>
              buttons[0]
            </td>
            <td>
              Bottom button in right cluster
            </td>
          </tr>
          <tr>
            <td>
              buttons[1]
            </td>
            <td>
              Right button in right cluster
            </td>
          </tr>
          <tr>
            <td>
              buttons[2]
            </td>
            <td>
              Left button in right cluster
            </td>
          </tr>
          <tr>
            <td>
              buttons[3]
            </td>
            <td>
              Top button in right cluster
            </td>
          </tr>
          <tr>
            <td>
              buttons[4]
            </td>
            <td>
              Top left front button
            </td>
          </tr>
          <tr>
            <td>
              buttons[5]
            </td>
            <td>
              Top right front button
            </td>
          </tr>
          <tr>
            <td>
              buttons[6]
            </td>
            <td>
              Bottom left front button
            </td>
          </tr>
          <tr>
            <td>
              buttons[7]
            </td>
            <td>
              Bottom right front button
            </td>
          </tr>
          <tr>
            <td>
              buttons[8]
            </td>
            <td>
              Left button in center cluster
            </td>
          </tr>
          <tr>
            <td>
              buttons[9]
            </td>
            <td>
              Right button in center cluster
            </td>
          </tr>
          <tr>
            <td>
              buttons[10]
            </td>
            <td>
              Left stick pressed button
            </td>
          </tr>
          <tr>
            <td>
              buttons[11]
            </td>
            <td>
              Right stick pressed button
            </td>
          </tr>
          <tr>
            <td>
              buttons[12]
            </td>
            <td>
              Top button in left cluster
            </td>
          </tr>
          <tr>
            <td>
              buttons[13]
            </td>
            <td>
              Bottom button in left cluster
            </td>
          </tr>
          <tr>
            <td>
              buttons[14]
            </td>
            <td>
              Left button in left cluster
            </td>
          </tr>
          <tr>
            <td>
              buttons[15]
            </td>
            <td>
              Right button in left cluster
            </td>
          </tr>
          <tr>
            <td>
              buttons[16]
            </td>
            <td>
              Center button in center cluster
            </td>
          </tr>
          <tr>
            <td>
              axes[0]
            </td>
            <td>
              Horizontal axis for left stick (negative left/positive right)
            </td>
          </tr>
          <tr>
            <td>
              axes[1]
            </td>
            <td>
              Vertical axis for left stick (negative up/positive down)
            </td>
          </tr>
          <tr>
            <td>
              axes[2]
            </td>
            <td>
              Horizontal axis for right stick (negative left/positive right)
            </td>
          </tr>
          <tr>
            <td>
              axes[3]
            </td>
            <td>
              Vertical axis for right stick (negative up/positive down)
            </td>
          </tr>
        </tbody>
      </table>
      <figure>
        <img src="standard_gamepad.svg" alt="">
        <figcaption>
          Visual representation of a standard gamepad layout.
        </figcaption>
      </figure>
    </section>
    <section class="informative">
      <h2>
        Usage Examples
      </h2>
      <p>
        The example below demonstrates typical access to gamepads. Note the
        relationship with the
        {{AnimationFrameProvider/requestAnimationFrame()}} method.
      </p>
      <pre class="example js">
        function runAnimation() {
            window.requestAnimationFrame(runAnimation);
            for (const pad of navigator.getGamepads()) {
              // todo; simple demo of displaying pad.axes and pad.buttons
              console.log(pad);
            }
        }

        window.requestAnimationFrame(runAnimation);
      </pre>
      <div class="practice">
        <span id="practice-timing" class="practicelab">Coordination with
        <code>requestAnimationFrame()</code></span>
        <p class="practicedesc">
          Interactive applications will typically be using the
          {{AnimationFrameProvider/requestAnimationFrame()}} method to drive
          animation, and will want coordinate animation with user gamepad
          input. As such, the gamepad data should be polled as closely as
          possible to immediately before the animation callbacks are executed,
          and with frequency matching that of the animation. That is, if the
          animation callbacks are running at 60Hz, the gamepad inputs should
          also be sampled at that rate.
        </p>
      </div>
    </section>
    <section>
      <h3 id="event-gamepadconnected">
        The <dfn class="event">gamepadconnected</dfn> event
      </h3>
      <p>
        User agents implementing this specification must provide a new DOM
        event, named <code>gamepadconnected</code>. The corresponding event
        MUST be of type {{GamepadEvent}} and, if <a>allowed to use</a> the
        "`gamepad`" permission, MUST fire on the <code>window</code> object.
        Registration for and firing of the <code>gamepadconnected</code> event
        MUST follow the usual behavior of DOM Events. [[DOM]]
      </p>
      <p>
        A <a>user agent</a> MUST dispatch this event type to indicate the user
        has connected a gamepad. If a gamepad was already connected when the
        page was loaded, the <a>gamepadconnected</a> event SHOULD be dispatched
        when the user presses a button or moves an axis.
      </p>
      <p>
        A <a>user agent</a> MUST NOT dispatch this event type if the
        <a>environment settings object</a> is a <a>non-secure context</a>.
      </p>
    </section>
    <section>
      <h3 id="event-gamepaddisconnected">
        The <dfn class="event">gamepaddisconnected</dfn> event
      </h3>
      <p>
        User agents implementing this specification must provide a new DOM
        event, named <code>gamepaddisconnected</code>. The corresponding event
        MUST be of type <code>GamepadEvent</code> and, if <a>allowed to use</a>
        the "`gamepad`" permission, MUST fire on the <code>window</code>
        object. Registration for and firing of the
        <code>gamepaddisconnected</code> event MUST follow the usual behavior
        of DOM Events. [[DOM]]
      </p>
      <p>
        When a gamepad is disconnected from the <a>user agent</a>, if the
        <a>user agent</a> has previously dispatched a <a>gamepadconnected</a>
        event for that gamepad to a window, a <a>gamepaddisconnected</a> event
        MUST be dispatched to that same window.
      </p>
      <p>
        A <a>user agent</a> MUST NOT dispatch this event type if the
        <a>environment settings object</a> is a <a>non-secure context</a>.
      </p>
    </section>
    <section>
      <h3>
        Other events
      </h3>
      <p>
        <i>More discussion needed, on whether to include or exclude axis and
        button changed events, and whether to roll them more together
        (<code>gamepadchanged</code>?), separate somewhat
        (<code>gamepadaxischanged</code>?), or separate by individual axis and
        button.</i>
      </p>
    </section>
    <section id="permission-policy" data-cite="Feature-Policy">
      <h2>
        Integration with Permissions Policy
      </h2>
      <p>
        This specification defines a policy-controlled feature identified by
        the string "`gamepad`". Its <a>default allowlist</a> is '`self`'.
      </p>
      <div class="note">
        <p>
          A <a>document</a>â€™s [=Document/permissions policy=] determines
          whether any content in that document is allowed to access
          {{Navigator/getGamepads()}}. If disabled in any document, no content
          in the document will be <a>allowed to use</a>
          {{Navigator/getGamepads()}}, nor will the "gamepadconnected" and
          "gamepaddisconnected" events fire.
        </p>
      </div>
    </section>
    <section id='conformance'>
      <p>
        This specification defines conformance criteria that apply to a single
        product: the <dfn id="dfn-user-agent">user agent</dfn> that implements
        the interfaces that it contains.
      </p>
    </section>
    <section class='appendix informative'>
      <h2>
        Acknowledgements
      </h2>
      <p>
        Many have made contributions in code, comments, or documentation:
      </p>
      <ul>
        <li>David Humphrey
        </li>
        <li>Gregg Tavares
        </li>
        <li>Marcin Wichary
        </li>
        <li>Jason Orendorff
        </li>
        <li>Olli Pettay
        </li>
        <li>Rick Waldron
        </li>
      </ul>
      <p>
        Please let me know if I have inadvertently omitted your name.
      </p>
    </section>
  </body>
</html>
