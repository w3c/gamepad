<!DOCTYPE html>
<html lang="en">
  <head>
    <title>
      Gamepad
    </title>
    <meta charset="utf-8"><!--
      === NOTA BENE ===
      For the three scripts below, if your spec resides on dev.w3 you can check them
      out in the same tree and use relative links so that they'll work offline,
     -->

    <script src='https://www.w3.org/Tools/respec/respec-w3c' class=
    'remove'></script>
    <script class='remove'>
      var respecConfig = {
          // specification status (e.g. WD, LCWD, NOTE, etc.). If in doubt use ED.
          specStatus:           "ED",
          // if your specification has a subtitle that goes below the main
          // formal title, define it here
          // subtitle   :  "an excellent document",

          // if you wish the publication date to be other than today, set this
          //publishDate:  "2011-01-01",

          // if the specification's copyright date is a range of years, specify
          // the start date here:
          // copyrightStart: "2005"

          // if there is a previously published draft, uncomment this and set its YYYY-MM-DD date
          // and its maturity status
          testSuiteURI: "https://w3c-test.org/gamepad/",

          // if this is a LCWD, uncomment and set the end of its review period
          // lcEnd: "2009-08-05",

          // editors, add as many as you like
          // only "name" is required
          editors:  [
              { name: "Steve Agoston",
                company: "Sony", companyURL: "https://www.sony.com/" },
              { name: "James Hollyer", w3cid: "115233",
                company: "Google", companyURL: "https://www.google.com/"},
              { name: "Matt Reynolds", w3cid: "105511",
                company: "Google", companyURL: "https://www.google.com/"},
          ],

          formerEditors: [
              { name: "Brandon Jones", url: "http://tojicode.com/",
                company: "Google", companyURL: "http://www.google.com/",
                w3cid: 87824 },
              { name: "Scott Graham", url: "http://h4ck3r.net/",
                company: "Google", companyURL: "https://www.google.com/",
                w3cid: 49028 },
              { name: "Ted Mielczarek", url: "http://ted.mielczarek.org/",
                company: "Mozilla", companyURL: "http://www.mozilla.org/",
                w3cid: 49656 },
          ],

          github: "w3c/gamepad",

          // authors, add as many as you like.
          // This is optional, uncomment if you have authors as well as editors.
          // only "name" is required. Same format as editors.

          //authors:  [
          //    { name: "Your Name", url: "http://example.org/",
          //      company: "Your Company", companyURL: "http://example.com/" },
          //],

          // name of the WG
          wg:           "Web Applications Working Group",

          // URI of the public WG page
          wgURI: "https://www.w3.org/2019/webapps/",

          // URI of the patent status for this WG, for Rec-track documents
          // !!!! IMPORTANT !!!!
          // This is important for Rec-track documents, do not copy a patent URI from a random
          // document unless you know what you're doing. If in doubt ask your friendly neighbourhood
          // Team Contact.
          wgPatentURI: "https://www.w3.org/2004/01/pp-impl/114929/status",
          implementationReportURI: "https://wpt.fyi/results/gamepad",
          // Disabled because https://github.com/Fyrd/caniuse/issues/4925
          // caniuse: "gamepad",
          xref: ["HTML", "DOM"],
      };
    </script>
    <style type="text/css">
      .event {
        font-family: monospace;
        color: #459900;
      }

      pre.idl {
        white-space: pre-wrap;
      }
      .tg {
        border-collapse: collapse;
        border-spacing: 0;

      }
      .tg th {
        border-style: solid;
        border-width: 1px;
        background: #90b8de;
        color: #fff;
        font-family: sans-serif;
        font-weight: bold;
        border-color: grey;
      }
      .tg td {
        padding: 4px 5px;
        background-color: rgb(221, 238, 255);
        font-family: monospace;
        border-style: solid;
        border-width: 1px;
        border-color: grey;
        overflow: hidden;
        word-break: normal;
      }
    </style>
  </head>
  <body>
    <section id='abstract'>
      <p>
        The Gamepad specification defines a low-level interface that represents
        gamepad devices.
      </p>
    </section>
    <section id='sotd'>
      <p>
        This is a work in progress.
      </p>
    </section>
    <section id='introduction' class='informative'>
      <h2>
        Introduction
      </h2>
      <p>
        Some <a>user agent</a>s have connected gamepad devices. These devices
        are desirable and suited to input for gaming applications, and for "10
        foot" user interfaces (presentations, media viewers).
      </p>
      <p>
        Currently, the only way for a gamepad to be used as input would be to
        emulate mouse or keyboard events, however this would lose information
        and require additional software outside of the <a>user agent</a> to
        accomplish emulation.
      </p>
      <p>
        Meanwhile, native applications are capable of accessing these devices
        via system APIs.
      </p>
      <p>
        The Gamepad API provides a solution to this problem by specifying
        interfaces that allow web applications to directly act on gamepad data.
      </p>
    </section>
    <section>
      <h2>
        Dependencies
      </h2>
      <p>
        This specification references interfaces from a number of other
        specifications:
      </p>
      <ul>
        <li>
          <dfn data-cite=
          "navigation-timing#performancetiming">PerformanceTiming</dfn>
          [[NAVIGATION-TIMING]].
        </li>
      </ul>
    </section>
    <section>
      <h2>
        Scope
      </h2>
      <p>
        Interfacing with external devices designed to control games has the
        potential to become large and intractable if approached in full
        generality. In this specification we explicitly choose to narrow scope
        to provide a useful subset of functionality that can be widely
        implemented and broadly useful.
      </p>
      <p>
        Specifically, we choose to only support the functionality required to
        support gamepads. Support for gamepads requires two input types:
        buttons and axes. Both buttons and axes are reported as analog values,
        buttons ranging from [0..1], and axes ranging from [-1..1].
      </p>
      <p>
        While the primary goal is support for gamepad devices, supporting these
        two types of analog inputs allows support for other similar devices
        common to current gaming systems including joysticks, driving wheels,
        pedals, and accelerometers. As such, the name "gamepad" is exemplary
        rather than trying to be a generic name for the entire set of devices
        addressed by this specification.
      </p>
      <p>
        We specifically exclude support for more complex devices that may also
        be used in some gaming contexts, including those that that do motion
        sensing, depth sensing, video analysis, gesture recognition, and so on.
      </p>
    </section>
    <section data-dfn-for="Gamepad" data-link-for="Gamepad">
      <h2>
        <dfn>Gamepad</dfn> interface
      </h2>
      <p>
        This interface represents an individual gamepad device. A Gamepad is a
        live object; that is, user interaction with the device will be reflected
        in the state of the object's properties. When the system receives new
        data from a connected gamepad, a microtask MUST be queued with the user
        interaction task source to update the state of the {{Gamepad}} object.
      </p>
      <pre class="idl" data-cite="HR-TIME">
        [Exposed=Window]
        interface Gamepad {
          readonly attribute DOMString id;
          readonly attribute long index;
          readonly attribute boolean connected;
          readonly attribute DOMHighResTimeStamp timestamp;
          readonly attribute GamepadMappingType mapping;
          readonly attribute FrozenArray&lt;double&gt; axes;
          readonly attribute FrozenArray&lt;GamepadButton&gt; buttons;
        };
      </pre>
      <dl>
        <dt>
          <dfn>id</dfn> attribute
        </dt>
        <dd>
          An identification string for the gamepad. This string identifies the
          brand or style of connected gamepad device. Typically, this will
          include the USB vendor and a product ID. The ID string MUST NOT change
          once the Gamepad object has been returned to script.
        </dd>
        <dt>
          <dfn>index</dfn> attribute
        </dt>
        <dd>
          <p>
          Zero-based index of the gamepad in the {{Navigator}}. The index
          MUST NOT change once the Gamepad object has been returned to script.
          </p>
          <p>
          When the system is notified that a gamepad has been connected,
          its index attribute MUST be assigned to the lowest index that is not
          assigned to any currently connected gamepad, starting at zero.
          </p>
          <p>
          When the system is notified that a previously connected gamepad has
          become unavailable, the `index` attribute of other gamepads MUST NOT
          be reassigned. However, if a gamepad is disconnected, and
          subsequently the same or a different gamepad is connected, the
          lowest previously used index MUST be assigned to the newly connected
          gamepad.
          </p>
        </dd>
        <dt>
          <dfn>connected</dfn> attribute
        </dt>
        <dd>
          <p>
          Indicates whether the physical device represented by this object is
          still connected to the system.
          </p>
          <p>
          When the system is notified that a previously-connected gamepad has
          become unavailable, whether by being physically disconnected,
          powered off, or otherwise unusable, a microtask MUST be queued with
          the user interaction task source to set the `connected` attribute to
          false.
          </p>
        </dd>
        <dt>
          <dfn>timestamp</dfn> attribute
        </dt>
        <dd>
          <p>
          Last time the data for this gamepad was updated. The `timestamp` is a
          monotonically increasing value that allows the author to determine if
          the <a>axes</a> and <a>button</a> data have been updated from the
          hardware. The value must be relative to the
          <code>navigationStart</code> attribute of the
          <a>PerformanceTiming</a> interface. Since values are monotonically
          increasing they can be compared to determine the ordering of updates,
          as newer values will always be greater than or equal to older values.
          </p>
          <p>
          If no data has been received from the hardware, the value of the
          <code>timestamp</code> attribute MUST be the time relative to
          <code>navigationStart</code> when the <a>Gamepad</a> object was first
          made available to script.
          </p>
          <p>
          When the system receives new data from a connected gamepad, a
          microtask MUST be queued with the user interaction task source to
          update the gamepad state. If the updated data would cause an
          observable change to the `buttons` or `axes` attributes, then the
          timestamp MUST be set to the time that the data was received from
          hardware, not the time when the microtask was executed.
          </p>
        </dd>
        <dt>
          <dfn>mapping</dfn> attribute
        </dt>
        <dd>
          The mapping in use for this device. If the user agent has knowledge
          of the layout of the device, then it SHOULD indicate that a mapping
          is in use by setting this property to a known mapping name. Currently
          the only known mapping is {{GamepadMappingType["standard"]}}, which
          corresponds to the <a>Standard Gamepad layout</a>. If the user agent
          does not have knowledge of the device layout and is simply providing
          the controls as represented by the driver in use, then it MUST set
          the `mapping` property to the empty string.
        </dd>
        <dt>
          <dfn>axes</dfn> attribute
        </dt>
        <dd>
          <p>
          Array of values for all axes of the gamepad. All axis values MUST be
          linearly normalized to the range [-1.0 .. 1.0]. If the controller is
          perpendicular to the ground with the directional stick pointing up,
          -1.0 SHOULD correspond to "forward" or "left", and 1.0 SHOULD
          correspond to "backward" or "right". Axes that are drawn from a 2D
          input device SHOULD appear next to each other in the axes array, X
          then Y. It is RECOMMENDED that axes appear in decreasing order of
          importance, such that element 0 and 1 typically represent the X and Y
          axis of a directional stick.
          </p>
          <p>
          When the system receives new data from a connected gamepad, a
          microtask MUST be queued with the user interaction task source to
          update the gamepad state. If the gamepad has the same axes in the same
          order as the previous update, and if no axis values have changed
          since the previous update, then the axes attribute MUST return the
          same array object. If the number of axes has changed, or if any axis
          value has changed, then the axis attribute MUST return a new array.
          </p>
          <p>
          Once the system is notified that a previously connected gamepad has
          been disconnected, the axes attribute MUST continue to return the
          last state received from the gamepad before disconnection.
          </p>
        </dd>
        <dt>
          <dfn>buttons</dfn> attribute
        </dt>
        <dd>
          <p>
          Array of {{GamepadButton}} objects representing the current state of
          all buttons of the gamepad. It is RECOMMENDED that buttons appear in
          decreasing importance such that the primary button, secondary
          button, tertiary button, and so on appear as elements 0, 1, 2, ...
          in the buttons array.
          </p>
          <p>
          When the system receives new data from a connected gamepad, a
          microtask MUST be queued with the user interaction task source to
          update the gamepad state. If the gamepad has the same buttons in the
          same order as the previous update, the buttons attribute MUST return
          the same array object. If the number of buttons or the ordering of
          buttons has changed, the buttons attribute MUST return a new array
          object. If a button in the new array represents the same physical
          button as a button from the previous array, the same GamepadButton
          object MUST be reused.
          </p>
        </dd>
      </dl>
    </section>
    <section data-dfn-for="GamepadButton" data-link-for="GamepadButton">
      <h2>
        <dfn>GamepadButton</dfn> Interface
      </h2>
      <p>
        This interface represents the current state of an individual button on a gamepad
        device. A {{GamepadButton}} is a live object; that is, user interaction with
        the button represented by the object will be reflected in the object's
        properties. When the system receives new data from a connected gamepad,
        a microtask MUST be queued with the user interaction task source to
        update the state of the GamepadButton objects representing the buttons
        on the gamepad.
      </p>
      <p>
        Once the system is notified that a previously-connected gamepad has been
        disconnected, the GamepadButton objects representing its buttons MUST
        continue to return the last state received from the gamepad before
        disconnection.
      </p>
      <pre class="idl">
        [Exposed=Window]
        interface GamepadButton {
          readonly attribute boolean pressed;
          readonly attribute boolean touched;
          readonly attribute double value;
        };
      </pre>
      <dl>
        <dt>
          <dfn>pressed</dfn> attribute
        </dt>
        <dd>
          The pressed state of the button. This property MUST be true if the
          button is currently pressed, and false if it is not pressed. For
          buttons which do not have a digital switch to indicate a pure pressed
          or released state, the user agent MUST choose a threshold value to
          indicate the button as pressed when its value is above a certain
          amount. If the platform API gives a recommended value, the user agent
          SHOULD use that. In other cases, the user agent SHOULD choose some
          other reasonable value.
        </dd>
        <dt>
          <dfn>touched</dfn> attribute
        </dt>
        <dd>
          The touched state of the button. If the button is capable of
          detecting touch this property MUST be true if the button is currently
          being touched and false otherwise. If the button is not capable of
          detecting touch and is capable of reporting an analog value this
          property MUST be true if the value property is greater than zero and
          false if the value is 0. If the button is not capable of detecting
          touch and can only report a digital value this property MUST mirror
          the pressed value.
        </dd>
        <dt>
          <dfn>value</dfn> attribute
        </dt>
        <dd>
          For buttons that have an analog sensor, this property MUST represent
          the amount which the button has been pressed. All button values MUST
          be linearly normalized to the range [0.0 .. 1.0]. 0.0 MUST mean fully
          unpressed, and 1.0 MUST mean fully pressed. For buttons without an
          analog sensor, only the values 0.0 and 1.0 for fully unpressed and
          fully pressed MUST be provided.
        </dd>
      </dl>
    </section>
    <section data-dfn-for="GamepadMappingType">
      <h2>
        <dfn>GamepadMappingType</dfn> enum
      </h2>
      <p>
        This enum defines the set of known mappings for a Gamepad.
      </p>
      <pre class="idl">
        enum GamepadMappingType {
          "",
          "standard",
        };
      </pre>
      <dl>
        <dt>
          <dfn>""</dfn>
        </dt>
        <dd>
          The empty string indicates that no mapping is in use for this
          gamepad.
        </dd>
        <dt>
          <dfn>standard</dfn>
        </dt>
        <dd>
          The Gamepad's controls have been mapped to the <a href=
          "#remapping">Standard Gamepad layout</a>.
        </dd>
      </dl>
    </section>
    <section data-dfn-for="Navigator">
      <h2>
        Navigator Interface extension
      </h2>
      <p>
        This partial interface defines an extension to the Navigator interface.
      </p>
      <pre class="idl">
        [Exposed=Window]
        partial interface Navigator {
          [NewObject] sequence&lt;Gamepad?&gt; getGamepads();
        };
      </pre>
      <dl>
        <dt>
          <dfn>getGamepads</dfn>
        </dt>
        <dd>
          Retrieve a sequence of {{Gamepad}} objects representing currently connected and
          interacted-with gamepads. Gamepads MUST only appear in the list if
          they are currently connected to the <a>user agent</a>, and at least
          one device has been interacted with by the user. If no devices have
          been interacted with, devices MUST NOT appear in the list to avoid a
          malicious page from fingerprinting the user. The length of the array
          returned MUST be one more than the maximum index value of the Gamepad
          objects returned in the array. The entries in the array MUST be the
          set of Gamepad objects that are visible to the current page, with
          each Gamepad present at the index in the array specified by its
          {{Gamepad/index}} attribute. Array indices for which there is no
          connected Gamepad with the corresponding index should return null.

          <p>
          A new array MUST be returned for each call to getGamepads().
          </p>
          
          <p>
          The gamepad state returned from getGamepads() does not reflect
          disconnection or connection until after the <a>gamepaddisconnected</a>
          or <a>gamepadconnected</a> events have fired.
          </p>

          <p>
            As an example, if there is one connected gamepad with an index of
            1, then the following code snippet describes the expected behavior:
          </p>
          <pre class="example highlight">
            // gamepads should look like [null, [object Gamepad]]
            var gamepads = navigator.getGamepads();
            // The following statements should all evaluate to true.
            gamepads[0] == null;
            gamepads[1].index == 1;
            gamepads.length == 2;
          </pre>
        </dd>
      </dl>
    </section>
    <section data-dfn-for="GamepadEvent">
      <h2>
        <dfn>GamepadEvent</dfn> Interface
      </h2>
      <pre class="idl" data-cite="DOM">
        [Exposed=Window]

        interface GamepadEvent: Event {
          constructor(DOMString type, GamepadEventInit eventInitDict);
          [SameObject] readonly attribute Gamepad gamepad;
        };
      </pre>
      <dl>
        <dt>
          <dfn>gamepad</dfn>
        </dt>
        <dd>
          The single gamepad attribute provides access to the associated
          gamepad data for this event.
        </dd>
      </dl>
      <section>
        <h3>
          <dfn>GamepadEventInit</dfn> dictionary
        </h3>
        <pre class="idl" data-cite="DOM">
        dictionary GamepadEventInit : EventInit {
          required Gamepad gamepad;
        };
      </pre>
        <dl data-dfn-for="GamepadEventInit">
          <dt>
            <dfn>gamepad</dfn> member
          </dt>
          <dd>
            The gamepad associated with this event.
          </dd>
        </dl>
      </section>
    </section>
    <section>
      <h2>
        <dfn data-lt="Standard Gamepad layout">Remapping</dfn>
      </h2>
      <p>
        Each device manufacturer creates many different products and each has
        unique styles and layouts of buttons and axes. It is intended that the
        <a>user agent</a> support as many of these as possible.
      </p>
      <p>
        Additionally there are <em>de facto</em> standard layouts that have
        been made popular by game consoles. When the <a>user agent</a>
        recognizes the attached device, it is RECOMMENDED that it be remapped
        to a canonical ordering when possible. Devices that are not recognized
        should still be exposed in their raw form.
      </p>
      <p data-link-for="Gamepad">
        There is currently one canonical device, the "Standard Gamepad". The
        standard gamepad has 4 axes, and up to 17 buttons. When remapping, the
        indices in <a>axes</a>[] and <a>buttons</a>[] should correspond as
        closely as possible to the physical locations in the diagram below.
        Additionally, the <a>mapping</a> property of the Gamepad SHOULD be set
        to the string {{GamepadMappingType["standard"]}}.
      </p>
      <p>
        The "Standard Gamepad" physical button locations are layed out in a
        left cluster of four buttons, a right cluster of four buttons, a center
        cluster of three buttons, and a pair of front facing buttons on the
        left and right side of the gamepad. The four axes of the "Standard
        Gamepad" are associated with a pair of analog sticks, one on the left
        and one on the right. The following table describes the buttons/axes
        and their physical locations.
      </p>
      <table class="tg">
        <thead>
          <tr>
            <th>
              Button/Axis
            </th>
            <th>
              Location
            </th>
          </tr>
        </thead>
        <tbody>
          <tr>
            <td>
              buttons[0]
            </td>
            <td>
              Bottom button in right cluster
            </td>
          </tr>
          <tr>
            <td>
              buttons[1]
            </td>
            <td>
              Right button in right cluster
            </td>
          </tr>
          <tr>
            <td>
              buttons[2]
            </td>
            <td>
              Left button in right cluster
            </td>
          </tr>
          <tr>
            <td>
              buttons[3]
            </td>
            <td>
              Top button in right cluster
            </td>
          </tr>
          <tr>
            <td>
              buttons[4]
            </td>
            <td>
              Top left front button
            </td>
          </tr>
          <tr>
            <td>
              buttons[5]
            </td>
            <td>
              Top right front button
            </td>
          </tr>
          <tr>
            <td>
              buttons[6]
            </td>
            <td>
              Bottom left front button
            </td>
          </tr>
          <tr>
            <td>
              buttons[7]
            </td>
            <td>
              Bottom right front button
            </td>
          </tr>
          <tr>
            <td>
              buttons[8]
            </td>
            <td>
              Left button in center cluster
            </td>
          </tr>
          <tr>
            <td>
              buttons[9]
            </td>
            <td>
              Right button in center cluster
            </td>
          </tr>
          <tr>
            <td>
              buttons[10]
            </td>
            <td>
              Left stick pressed button
            </td>
          </tr>
          <tr>
            <td>
              buttons[11]
            </td>
            <td>
              Right stick pressed button
            </td>
          </tr>
          <tr>
            <td>
              buttons[12]
            </td>
            <td>
              Top button in left cluster
            </td>
          </tr>
          <tr>
            <td>
              buttons[13]
            </td>
            <td>
              Bottom button in left cluster
            </td>
          </tr>
          <tr>
            <td>
              buttons[14]
            </td>
            <td>
              Left button in left cluster
            </td>
          </tr>
          <tr>
            <td>
              buttons[15]
            </td>
            <td>
              Right button in left cluster
            </td>
          </tr>
          <tr>
            <td>
              axes[0]
            </td>
            <td>
              Horizontal axis for left stick (negative left/positive right)
            </td>
          </tr>
          <tr>
            <td>
              axes[1]
            </td>
            <td>
              Vertical axis for left stick (negative up/positive down)
            </td>
          </tr>
          <tr>
            <td>
              axes[2]
            </td>
            <td>
              Horizontal axis for right stick (negative left/positive right)
            </td>
          </tr>
          <tr>
            <td>
              axes[3]
            </td>
            <td>
              Vertical axis for right stick (negative up/positive down)
            </td>
          </tr>
        </tbody>
      </table>
      <figure>
        <img src="standard_gamepad.svg" alt="">
        <figcaption>
          Visual representation of a standard gamepad layout.
        </figcaption>
      </figure>
    </section>
    <section class="informative">
      <h2>
        Usage Examples
      </h2>
      <p>
        The example below demonstrates typical access to gamepads. Note the
        relationship with the
        {{AnimationFrameProvider/requestAnimationFrame()}} method.
      </p>
      <pre class="example js">
        function runAnimation() {
            window.requestAnimationFrame(runAnimation);
            for (const pad of navigator.getGamepads()) {
              // todo; simple demo of displaying pad.axes and pad.buttons
              console.log(pad);
            }
        }

        window.requestAnimationFrame(runAnimation);
      </pre>
      <div class="practice">
        <span id="practice-timing" class="practicelab">Coordination with
        <code>requestAnimationFrame()</code></span>
        <p class="practicedesc">
          Interactive applications will typically be using the
          {{AnimationFrameProvider/requestAnimationFrame()}} method to drive
          animation, and will want coordinate animation with user gamepad
          input. As such, the gamepad data should be polled as closely as
          possible to immediately before the animation callbacks are executed,
          and with frequency matching that of the animation. That is, if the
          animation callbacks are running at 60Hz, the gamepad inputs should
          also be sampled at that rate.
        </p>
      </div>
    </section>
    <section>
      <h3 id="event-gamepadconnected">
        The <dfn class="event">gamepadconnected</dfn> event
      </h3>
      <p>
        User agents implementing this specification must provide a new DOM
        event, named <code>gamepadconnected</code>. The corresponding event
        MUST be of type <code>GamepadEvent</code> and MUST fire on the
        <code>window</code> object. Registration for and firing of the
        <code>gamepadconnected</code> event MUST follow the usual behavior of
        DOM Events. [[DOM]]
      </p>
      <p>
        When the system is notified that a gamepad has been connected, a
        microtask MUST be queued with the user interaction task source to fire a
        <a>gamepadconnected</a> event.
        A <a>user agent</a> MUST dispatch this event type to indicate the user
        has connected a gamepad. If a gamepad was already connected when the
        page was loaded, the <a>gamepadconnected</a> event SHOULD be dispatched
        when the user presses a button or moves an axis on any connected
        gamepad.
      </p>
    </section>
    <section>
      <h3 id="event-gamepaddisconnected">
        The <dfn class="event">gamepaddisconnected</dfn> event
      </h3>
      <p>
        User agents implementing this specification must provide a new DOM
        event, named <code>gamepaddisconnected</code>. The corresponding event
        MUST be of type <code>GamepadEvent</code> and MUST fire on the
        <code>window</code> object. Registration for and firing of the
        <code>gamepaddisconnected</code> event MUST follow the usual behavior
        of DOM Events. [[DOM]]
      </p>
      <p>
        If a <a>gamepadconnected</a> event was previously dispatched for a
        particular gamepad and the system is notified that the gamepad has
        become unavailable, a microtask MUST be queued with the user interaction
        task source to dispatch a <a>gamepaddisconnected</a> event to the same
        window.
      </p>
    </section>
    <section>
      <h3>
        Other events
      </h3>
      <p>
        <i>More discussion needed, on whether to include or exclude axis and
        button changed events, and whether to roll them more together
        (<code>gamepadchanged</code>?), separate somewhat
        (<code>gamepadaxischanged</code>?), or separate by individual axis and
        button.</i>
      </p>
    </section>
    <section id='conformance'>
      <p>
        This specification defines conformance criteria that apply to a single
        product: the <dfn id="dfn-user-agent">user agent</dfn> that implements
        the interfaces that it contains.
      </p>
    </section>
    <section class='appendix informative'>
      <h2>
        Acknowledgements
      </h2>
      <p>
        Many have made contributions in code, comments, or documentation:
      </p>
      <ul>
        <li>David Humphrey
        </li>
        <li>Gregg Tavares
        </li>
        <li>Marcin Wichary
        </li>
        <li>Jason Orendorff
        </li>
        <li>Olli Pettay
        </li>
        <li>Rick Waldron
        </li>
      </ul>
      <p>
        Please let me know if I have inadvertently omitted your name.
      </p>
    </section>
  </body>
</html>
